# Qiling Rootfs Setup

Qiling Framework requires OS-specific files (DLLs, system libraries, registry
hives) to emulate binaries. These are called the **rootfs** and must be placed
in a specific directory structure.

**Linux emulation works out of the box** — the Docker image pre-populates Linux
rootfs files at build time. **Windows and macOS emulation** require files from
a real installation that cannot be legally redistributed.

## Quick Start

### 1. Create the rootfs directory

```bash
mkdir -p qiling-rootfs
```

This directory sits next to `run.sh` and is automatically mounted into the
container at `/app/qiling-rootfs/`.

### 2. Copy Windows system files (for Windows PE emulation)

From a Windows machine, copy the required files:

```powershell
# Run this on a Windows machine (PowerShell)

# 32-bit rootfs
mkdir qiling-rootfs\x86_windows\Windows\System32
xcopy /E /Y C:\Windows\SysWOW64\*.dll qiling-rootfs\x86_windows\Windows\System32\

# 64-bit rootfs
mkdir qiling-rootfs\x8664_windows\Windows\System32
xcopy /E /Y C:\Windows\System32\*.dll qiling-rootfs\x8664_windows\Windows\System32\
```

Or from a Linux host with access to a Windows partition/VM:

```bash
# 32-bit (copy from SysWOW64 for 32-bit DLLs)
mkdir -p qiling-rootfs/x86_windows/Windows/System32
cp /mnt/windows/Windows/SysWOW64/*.dll qiling-rootfs/x86_windows/Windows/System32/

# 64-bit
mkdir -p qiling-rootfs/x8664_windows/Windows/System32
cp /mnt/windows/Windows/System32/*.dll qiling-rootfs/x8664_windows/Windows/System32/
```

> **Note:** Registry hive stubs are auto-generated by PeMCP — you do not need
> to copy registry files.

### 3. Run PeMCP

```bash
# run.sh auto-detects ./qiling-rootfs/ if it exists
./run.sh

# Or specify a custom path
./run.sh --rootfs /path/to/my/rootfs

# Or via environment variable
PEMCP_ROOTFS=/path/to/my/rootfs ./run.sh

# Or via docker compose
PEMCP_ROOTFS=/path/to/my/rootfs docker compose up pemcp-http
```

## Directory Structure

```
qiling-rootfs/
  x86_windows/               # 32-bit Windows
    Windows/
      System32/
        ntdll.dll             # Required
        kernel32.dll          # Required
        user32.dll            # Recommended
        advapi32.dll          # Recommended
        ws2_32.dll            # For network API emulation
        wininet.dll           # For HTTP API emulation
        msvcrt.dll            # For C runtime calls
        ucrtbase.dll          # For Universal CRT calls
        ...                   # More DLLs = better emulation coverage
      registry/               # Auto-generated (do not copy)
        NTUSER.DAT
        SAM, SECURITY, SOFTWARE, SYSTEM, HARDWARE

  x8664_windows/              # 64-bit Windows (same structure)
    Windows/
      System32/
        ntdll.dll
        kernel32.dll
        ...

  x86_linux/                  # Pre-populated by Docker build
    lib/
    bin/
    ...

  x8664_linux/                # Pre-populated by Docker build
    lib/
    lib64/
    bin/
    ...

  x8664_macos/                # macOS (if needed)
    ...
```

## What Each OS Needs

### Windows (user-provided)

| Component | Location | Notes |
|-----------|----------|-------|
| System DLLs | `Windows/System32/*.dll` | From a real Windows install |
| Registry hives | `Windows/registry/` | **Auto-generated** by PeMCP |

**Minimum DLLs for basic emulation:**
- `ntdll.dll` — Native API (always needed)
- `kernel32.dll` — Win32 base API (always needed)
- `user32.dll` — UI functions
- `advapi32.dll` — Registry, crypto, service APIs
- `ws2_32.dll` — Winsock (network calls)
- `msvcrt.dll` — C runtime

**For 32-bit PE files:** Use DLLs from `C:\Windows\SysWOW64\` (these are the
32-bit versions despite the directory name).

**For 64-bit PE files:** Use DLLs from `C:\Windows\System32\` (these are the
64-bit versions).

### Linux (pre-populated)

Linux rootfs is downloaded from the
[qilingframework/rootfs](https://github.com/qilingframework/rootfs) repository
at Docker build time. It includes `/lib/`, `/bin/`, and kernel stubs. No user
action is needed.

### macOS (user-provided)

macOS emulation requires system libraries from a real macOS installation in
`x8664_macos/`. This is rarely needed for malware analysis.

## What Works Without Windows DLLs

Even without Windows DLL files:

- **Linux ELF emulation** — Fully functional
- **Shellcode emulation** — Works for all architectures (Windows shellcode runs
  but API hooking has limited coverage without DLLs)
- **API hash resolution** — Standalone, no emulation needed
- **Windows PE emulation** — Partially works (Qiling initializes but cannot
  resolve imports, limiting behavioral analysis)

## Troubleshooting

### "Windows registry hive not found"

PeMCP auto-generates registry hive stubs. If you see this error, the rootfs
directory may not be mounted correctly. Check:

```bash
# Verify the mount
docker exec <container> ls /app/qiling-rootfs/x86_windows/Windows/registry/
```

### "Could not find DLL file: ..."

Windows DLLs are not included. Copy them from a Windows installation as
described above.

### Permission errors on rootfs

The container runs as your host user (non-root). Make sure the rootfs directory
is readable:

```bash
chmod -R a+rX qiling-rootfs/
```

### Using a Windows VM to get DLLs

If you don't have a Windows machine, you can:

1. Download a free Windows evaluation VM from
   [Microsoft](https://developer.microsoft.com/en-us/windows/downloads/virtual-machines/)
2. Mount the VM disk image and copy the DLLs
3. Or use a minimal Windows Docker image to extract them:

```bash
# Extract 64-bit DLLs from a Windows container
docker create --name wintemp mcr.microsoft.com/windows/nanoserver:ltsc2022
docker cp wintemp:Windows/System32 qiling-rootfs/x8664_windows/Windows/System32
docker rm wintemp
```
